---
phase: 04-mcp-communication-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_mcp_multi_agent.py
autonomous: true

must_haves:
  truths:
    - "Agent A sends a message through send_message MCP tool and agent B receives it via read_inbox MCP tool"
    - "Agent B sends a reply through send_message MCP tool and agent A receives it via read_inbox MCP tool"
    - "Task created by one agent context is visible to another agent context via task_list"
    - "Messages and tasks persist to JSON files on disk under the team directory"
    - "Two concurrent MCP server contexts share the same filesystem state (not isolated per process)"
  artifacts:
    - path: "tests/test_mcp_multi_agent.py"
      provides: "Integration tests for multi-agent state sharing and message exchange"
      min_lines: 150
  key_links:
    - from: "tests/test_mcp_multi_agent.py"
      to: "src/claude_teams/server.py"
      via: "fastmcp.Client(mcp) tool calls simulating two agents"
      pattern: "client\\.call_tool"
    - from: "src/claude_teams/messaging.py"
      to: "filesystem"
      via: "JSON inbox files under TEAMS_DIR"
      pattern: "path\\.write_text"
    - from: "src/claude_teams/tasks.py"
      to: "filesystem"
      via: "JSON task files under TASKS_DIR"
      pattern: "fpath\\.write_text"
---

<objective>
Validate that two agents spawned in the same team can exchange messages through the MCP server and that state persists correctly on the filesystem.

Purpose: Confirm MCP-03 requirement -- MCP server state is shared across all spawned agents via the filesystem backend. Also validates the bidirectional message exchange success criterion.
Output: New test file `tests/test_mcp_multi_agent.py` with passing tests covering cross-agent messaging, task visibility, and filesystem state verification.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/test_server.py
@src/claude_teams/server.py
@src/claude_teams/messaging.py
@src/claude_teams/tasks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-agent message exchange tests</name>
  <files>tests/test_mcp_multi_agent.py</files>
  <action>
Create a new test file `tests/test_mcp_multi_agent.py` with two test classes.

**Class `TestMultiAgentMessageExchange`:**

Use a single `Client(mcp)` session (simulating the shared MCP server) to test that two agents can exchange messages. The key insight: all agents share the SAME MCP server process in production (each gets their own via STDIO, but they all read/write the same filesystem). In tests, one `Client` session is sufficient because the filesystem is the shared state.

Setup pattern (same monkeypatching as test_server.py):
- monkeypatch `teams.TEAMS_DIR`, `teams.TASKS_DIR`, `tasks.TASKS_DIR`, `messaging.TEAMS_DIR` to `tmp_path`
- monkeypatch `discover_opencode_binary` to return "/usr/bin/echo"
- Create team, add members "alice" and "bob"

Tests:

1. `test_alice_sends_bob_receives` -- Alice sends message to bob via `send_message(team_name, type="message", recipient="bob", content="hello bob", summary="greeting", sender="alice")`. Bob reads inbox via `read_inbox(team_name, agent_name="bob")`. Assert message has `from="alice"` and `text="hello bob"`.

2. `test_bob_replies_alice_receives` -- Bob sends to alice, alice reads. Bidirectional proof. Use `sender="bob"` explicitly.

3. `test_full_conversation_round_trip` -- Alice sends to bob, bob reads, bob replies to alice, alice reads. Full round trip. Assert message ordering and content correctness.

4. `test_broadcast_reaches_all_agents` -- Team-lead sends broadcast. Both alice and bob receive it. Verify both inboxes have the message.

5. `test_task_assignment_notification_reaches_agent` -- Create task, assign to alice via `task_update(owner="alice")`. Alice's inbox should contain a `task_assignment` structured message. Parse the JSON in the `text` field and verify `taskId`, `subject`, `assignedBy`.

**Class `TestMultiAgentTaskSharing`:**

6. `test_task_created_visible_to_all` -- Create a task. Call `task_list` (any agent can do this). Assert the task is visible. This confirms tasks are team-scoped, not agent-scoped.

7. `test_task_status_update_visible_to_all` -- Create task, update status to in_progress, call `task_get` and verify status change is visible.

8. `test_multiple_agents_claim_different_tasks` -- Create 2 tasks. Assign task 1 to alice, task 2 to bob. Call `task_list` and verify both owners are set correctly.

Key details:
- Always add members via `teams.add_member(team_name, _make_teammate(...))` BEFORE sending messages to them (pitfall #2 from research).
- Use `mark_as_read=True` (default) when reading inbox, but be aware messages are marked read after first read (pitfall #3).
- Use unique team names per test to avoid state leakage.
- Duplicate `_make_teammate` and `_data` helpers locally in this file for isolation.
  </action>
  <verify>Run `pytest tests/test_mcp_multi_agent.py -v` -- all tests pass.</verify>
  <done>8 tests pass covering bidirectional agent messaging, broadcast delivery, task assignment notifications, shared task visibility, and multi-agent task claiming.</done>
</task>

<task type="auto">
  <name>Task 2: Filesystem state verification tests</name>
  <files>tests/test_mcp_multi_agent.py</files>
  <action>
Add a third test class `TestFilesystemStateSharing` to the same file `tests/test_mcp_multi_agent.py`.

These tests verify MCP-03 at the filesystem level -- confirming that JSON files on disk match expected state after MCP tool operations. This is the "empirical confirmation" the blockers in STATE.md called for.

Tests:

1. `test_inbox_file_exists_after_send` -- Create team, add "alice", send message to alice via MCP tool. Then directly read `tmp_path / "teams" / team_name / "inboxes" / "alice.json"` and assert:
   - File exists
   - JSON-parseable
   - Contains exactly 1 message
   - Message has correct `from` and `text` fields

2. `test_task_file_exists_after_create` -- Create team, create task via MCP tool. Then directly read `tmp_path / "tasks" / team_name / "1.json"` and assert:
   - File exists
   - JSON-parseable
   - Has `subject`, `description`, `status="pending"` fields

3. `test_cross_context_state_visible` -- This is the critical multi-process simulation test. Use TWO separate `Client(mcp)` sessions sharing the SAME `tmp_path`:
   - Client 1: create team, add alice and bob
   - Client 1: alice sends message to bob
   - Client 2: (new Client session, same monkeypatched dirs) bob reads inbox
   - Assert bob receives the message sent by client 1's session

   Implementation:
   ```python
   async with Client(mcp) as client1:
       await client1.call_tool("team_create", {"team_name": "cross"})
       teams.add_member("cross", _make_teammate("alice", "cross"))
       teams.add_member("cross", _make_teammate("bob", "cross"))
       await client1.call_tool("send_message", {
           "team_name": "cross", "type": "message",
           "recipient": "bob", "content": "cross-context test",
           "summary": "xctx", "sender": "alice"
       })

   # New client session -- simulates separate MCP server process
   async with Client(mcp) as client2:
       inbox = _data(await client2.call_tool("read_inbox", {
           "team_name": "cross", "agent_name": "bob"
       }))
       assert len(inbox) == 1
       assert inbox[0]["text"] == "cross-context test"
       assert inbox[0]["from"] == "alice"
   ```

   NOTE: The second `Client(mcp)` will trigger a fresh lifespan. Monkeypatch `discover_opencode_binary` to avoid needing the actual binary. The lifespan creates a new session_id and active_team=None, but that's fine -- the team already exists on disk. The second client does NOT need to call `team_create` -- it just reads from the existing filesystem state.

   IMPORTANT: The second client's lifespan sets `active_team=None`, so calling `team_create` would fail with "Session already has active team" only if one was already set. Since it's a fresh session, `active_team` starts as None. But since we DON'T need to create the team (it exists), we just call `read_inbox` directly which doesn't require `active_team`.

4. `test_task_file_reflects_owner_after_update` -- Create team, create task, update owner to "alice" via MCP tool. Directly read the task JSON file from disk and verify `owner` field is set.

This for this class, use a DIFFERENT fixture that does NOT wrap `Client(mcp)` -- instead, just set up the monkeypatching and dirs, and create Client instances manually within the tests (needed for test 3's two-client pattern).

```python
@pytest.fixture
async def mcp_dirs(tmp_path: Path, monkeypatch):
    monkeypatch.setattr(teams, "TEAMS_DIR", tmp_path / "teams")
    monkeypatch.setattr(teams, "TASKS_DIR", tmp_path / "tasks")
    monkeypatch.setattr(tasks, "TASKS_DIR", tmp_path / "tasks")
    monkeypatch.setattr(messaging, "TEAMS_DIR", tmp_path / "teams")
    monkeypatch.setattr(
        "claude_teams.server.discover_opencode_binary", lambda: "/usr/bin/echo"
    )
    (tmp_path / "teams").mkdir()
    (tmp_path / "tasks").mkdir()
    return tmp_path
```
  </action>
  <verify>Run `pytest tests/test_mcp_multi_agent.py -v` -- all tests pass (both existing and new).</verify>
  <done>4 additional filesystem tests pass, confirming: inbox JSON files exist with correct content after send_message, task JSON files exist after task_create, cross-context state is visible across separate Client sessions, and task owner updates persist to disk.</done>
</task>

</tasks>

<verification>
- `pytest tests/test_mcp_multi_agent.py -v` -- all 12 tests pass
- Cross-context test (test_cross_context_state_visible) proves two independent MCP client sessions share filesystem state
- Filesystem-level assertions confirm JSON files contain expected data
- Full test suite: `pytest tests/ -v` -- all tests pass (existing + new)
</verification>

<success_criteria>
- 12 tests pass in test_mcp_multi_agent.py covering message exchange, task sharing, and filesystem verification
- Cross-context test demonstrates that state written by one Client(mcp) session is readable by another
- Blockers from STATE.md ("MCP server state sharing across spawned agents needs empirical confirmation") are addressed
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-communication-validation/04-02-SUMMARY.md`
</output>
